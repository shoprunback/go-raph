use 'godoc cmd/go-raph/raph' for documentation on the go-raph/raph command 

<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "go-raph/raph"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				
				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#Contains">func Contains(s []string, e string) bool</a></dd>
			
				
				<dd><a href="#ContainsAll">func ContainsAll(s []string, e []string) bool</a></dd>
			
				
				<dd><a href="#ContainsOne">func ContainsOne(s []string, e []string) bool</a></dd>
			
				
				<dd><a href="#RandSeq">func RandSeq(n int) string</a></dd>
			
				
				<dd><a href="#Remove">func Remove(s []string, i int) []string</a></dd>
			
				
				<dd><a href="#Reverse">func Reverse(s []string)</a></dd>
			
			
				
				<dd><a href="#Constraint">type Constraint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewConstraint">func NewConstraint(label string) *Constraint</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Constraint.Copy">func (c Constraint) Copy() *Constraint</a></dd>
				
			
				
				<dd><a href="#Dijkstra">type Dijkstra</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDijkstra">func NewDijkstra(g Graph) *Dijkstra</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Dijkstra.GetCost">func (d Dijkstra) GetCost(id string) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dijkstra.PickVertexFromQ">func (d *Dijkstra) PickVertexFromQ() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dijkstra.Reset">func (d *Dijkstra) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dijkstra.ShortestPath">func (d *Dijkstra) ShortestPath(from, to string, constraint Constraint, minimize ...string) ([]string, int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dijkstra.ShortestPathDetailed">func (d *Dijkstra) ShortestPathDetailed(from, to string, constraint Constraint, minimize ...string) ([]map[string]interface{}, int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dijkstra.UpdateDistances">func (d *Dijkstra) UpdateDistances(s1, s2, edge string, s1s2Weight int)</a></dd>
				
			
				
				<dd><a href="#Edge">type Edge</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEdge">func NewEdge(id, label, from, to string) *Edge</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMultiEdge">func NewMultiEdge(id, label string, froms, tos map[string]bool) *Edge</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Edge.ToJSON">func (e Edge) ToJSON() map[string]interface{}</a></dd>
				
			
				
				<dd><a href="#Graph">type Graph</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGraph">func NewGraph() *Graph</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Graph.AddEdge">func (g *Graph) AddEdge(e *Edge)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Graph.AddVertex">func (g *Graph) AddVertex(v *Vertex)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Graph.Connect">func (g *Graph) Connect(from, to, label string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Graph.GetAccessibleVertices">func (g Graph) GetAccessibleVertices(vertex string, constraint Constraint) map[string]bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Graph.GetConnections">func (g *Graph) GetConnections(id, label string) []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Graph.GetNeighbors">func (g Graph) GetNeighbors(vertex string, constraint Constraint) map[string]bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Graph.GetNeighborsWithCostsAndEdges">func (g Graph) GetNeighborsWithCostsAndEdges(vertex string, constraint Constraint, costs ...string) (map[string]int, map[string]string)</a></dd>
				
			
				
				<dd><a href="#Path">type Path</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPath">func NewPath(from, to string, vertices, edges map[string]string) *Path</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Path.Append">func (p Path) Append(path2 []string) []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Path.Get">func (p Path) Get() []string</a></dd>
				
			
				
				<dd><a href="#Vertex">type Vertex</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewVertex">func NewVertex(id, label string) *Vertex</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vertex.AddProp">func (v *Vertex) AddProp(prop, value string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vertex.Satisfies">func (v Vertex) Satisfies(constraint Constraint) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vertex.SetCost">func (v *Vertex) SetCost(cost string, value int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vertex.ToJSON">func (v Vertex) ToJSON() map[string]interface{}</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/go-raph/raph/constraint.go">constraint.go</a>
			
				<a href="/src/go-raph/raph/dijkstra.go">dijkstra.go</a>
			
				<a href="/src/go-raph/raph/edge.go">edge.go</a>
			
				<a href="/src/go-raph/raph/graph.go">graph.go</a>
			
				<a href="/src/go-raph/raph/path.go">path.go</a>
			
				<a href="/src/go-raph/raph/utils.go">utils.go</a>
			
				<a href="/src/go-raph/raph/vertex.go">vertex.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>
Sets MaxCost to MaxInt.
</p>

				<pre>const (
    <span id="MaxUint">MaxUint</span> = ^<a href="/pkg/builtin/#uint">uint</a>(0)
    <span id="MaxInt">MaxInt</span>  = <a href="/pkg/builtin/#int">int</a>(<a href="#MaxUint">MaxUint</a> &gt;&gt; 1)
    <span id="MaxCost">MaxCost</span> = <a href="#MaxInt">MaxInt</a>
)</pre>
			
		
		
		
			
			
			<h2 id="Contains">func <a href="/src/target/utils.go?s=98:138#L2">Contains</a>
				<a class="permalink" href="#Contains">&#xb6;</a>
			</h2>
			<pre>func Contains(s []<a href="/pkg/builtin/#string">string</a>, e <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			
			
			

		
			
			
			<h2 id="ContainsAll">func <a href="/src/target/utils.go?s=376:421#L22">ContainsAll</a>
				<a class="permalink" href="#ContainsAll">&#xb6;</a>
			</h2>
			<pre>func ContainsAll(s []<a href="/pkg/builtin/#string">string</a>, e []<a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			
			
			

		
			
			
			<h2 id="ContainsOne">func <a href="/src/target/utils.go?s=217:262#L11">ContainsOne</a>
				<a class="permalink" href="#ContainsOne">&#xb6;</a>
			</h2>
			<pre>func ContainsOne(s []<a href="/pkg/builtin/#string">string</a>, e []<a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			
			
			

		
			
			
			<h2 id="RandSeq">func <a href="/src/target/utils.go?s=877:903#L51">RandSeq</a>
				<a class="permalink" href="#RandSeq">&#xb6;</a>
			</h2>
			<pre>func RandSeq(n <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="Remove">func <a href="/src/target/utils.go?s=596:635#L38">Remove</a>
				<a class="permalink" href="#Remove">&#xb6;</a>
			</h2>
			<pre>func Remove(s []<a href="/pkg/builtin/#string">string</a>, i <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#string">string</a></pre>
			
			
			

		
			
			
			<h2 id="Reverse">func <a href="/src/target/utils.go?s=682:706#L43">Reverse</a>
				<a class="permalink" href="#Reverse">&#xb6;</a>
			</h2>
			<pre>func Reverse(s []<a href="/pkg/builtin/#string">string</a>)</pre>
			
			
			

		
		
			
			
			<h2 id="Constraint">type <a href="/src/target/constraint.go?s=230:264#L1">Constraint</a>
				<a class="permalink" href="#Constraint">&#xb6;</a>
			</h2>
			<p>
Constraint is the constraint used to filter out nodes. It inheritates from Vertex structure because it behaves more or less like a Vertex against which we will compare vertices and edges. Its ID is not important.
</p>

			<pre>type Constraint struct {
    <a href="#Vertex">Vertex</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewConstraint">func <a href="/src/target/constraint.go?s=326:370#L1">NewConstraint</a>
					<a class="permalink" href="#NewConstraint">&#xb6;</a>
				</h3>
				<pre>func NewConstraint(label <a href="/pkg/builtin/#string">string</a>) *<a href="#Constraint">Constraint</a></pre>
				<p>
NewConstraint returns a constraint with specified label.
</p>

				
				
			

			
				
				<h3 id="Constraint.Copy">func (Constraint) <a href="/src/target/constraint.go?s=468:506#L4">Copy</a>
					<a class="permalink" href="#Constraint.Copy">&#xb6;</a>
				</h3>
				<pre>func (c <a href="#Constraint">Constraint</a>) Copy() *<a href="#Constraint">Constraint</a></pre>
				<p>
Copy returns a copy of the constraint.
</p>

				
				
				
			
		
			
			
			<h2 id="Dijkstra">type <a href="/src/target/dijkstra.go?s=74:204#L1">Dijkstra</a>
				<a class="permalink" href="#Dijkstra">&#xb6;</a>
			</h2>
			<p>
Dijkstra instance is used to compute Dijkstra algorithm.
</p>

			<pre>type Dijkstra struct {
<span id="Dijkstra.G"></span>    G      <a href="#Graph">Graph</a>
<span id="Dijkstra.Q"></span>    Q      []<a href="/pkg/builtin/#string">string</a>
<span id="Dijkstra.Costs"></span>    Costs  map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>
<span id="Dijkstra.PredsV"></span>    PredsV map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>
<span id="Dijkstra.PredsE"></span>    PredsE map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewDijkstra">func <a href="/src/target/dijkstra.go?s=311:346#L9">NewDijkstra</a>
					<a class="permalink" href="#NewDijkstra">&#xb6;</a>
				</h3>
				<pre>func NewDijkstra(g <a href="#Graph">Graph</a>) *<a href="#Dijkstra">Dijkstra</a></pre>
				
				
				
			

			
				
				<h3 id="Dijkstra.GetCost">func (Dijkstra) <a href="/src/target/dijkstra.go?s=983:1023#L36">GetCost</a>
					<a class="permalink" href="#Dijkstra.GetCost">&#xb6;</a>
				</h3>
				<pre>func (d <a href="#Dijkstra">Dijkstra</a>) GetCost(id <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>
GetCost returns the cost of speficied vertex. If it has not been set by UpdateDistances yet, it returns MaxCost.
</p>

				
				
				
			
				
				<h3 id="Dijkstra.PickVertexFromQ">func (*Dijkstra) <a href="/src/target/dijkstra.go?s=1194:1237#L45">PickVertexFromQ</a>
					<a class="permalink" href="#Dijkstra.PickVertexFromQ">&#xb6;</a>
				</h3>
				<pre>func (d *<a href="#Dijkstra">Dijkstra</a>) PickVertexFromQ() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
PickVertexFromQ returns the vertex with minimal cost and removes it from the queue.
</p>

				
				
				
			
				
				<h3 id="Dijkstra.Reset">func (*Dijkstra) <a href="/src/target/dijkstra.go?s=811:837#L31">Reset</a>
					<a class="permalink" href="#Dijkstra.Reset">&#xb6;</a>
				</h3>
				<pre>func (d *<a href="#Dijkstra">Dijkstra</a>) Reset()</pre>
				<p>
Reset resets the Dijkstra instance for further use.
</p>

				
				
				
			
				
				<h3 id="Dijkstra.ShortestPath">func (*Dijkstra) <a href="/src/target/dijkstra.go?s=2649:2756#L95">ShortestPath</a>
					<a class="permalink" href="#Dijkstra.ShortestPath">&#xb6;</a>
				</h3>
				<pre>func (d *<a href="#Dijkstra">Dijkstra</a>) ShortestPath(from, to <a href="/pkg/builtin/#string">string</a>, constraint <a href="#Constraint">Constraint</a>, minimize ...<a href="/pkg/builtin/#string">string</a>) ([]<a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
ShortestPath returns a slice of ids with its cost.
</p>

				
				
				
			
				
				<h3 id="Dijkstra.ShortestPathDetailed">func (*Dijkstra) <a href="/src/target/dijkstra.go?s=1916:2047#L73">ShortestPathDetailed</a>
					<a class="permalink" href="#Dijkstra.ShortestPathDetailed">&#xb6;</a>
				</h3>
				<pre>func (d *<a href="#Dijkstra">Dijkstra</a>) ShortestPathDetailed(from, to <a href="/pkg/builtin/#string">string</a>, constraint <a href="#Constraint">Constraint</a>, minimize ...<a href="/pkg/builtin/#string">string</a>) ([]map[<a href="/pkg/builtin/#string">string</a>]interface{}, <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
ShortestPathDetailed returns detailed shortest path with its cost.
</p>

				
				
				
			
				
				<h3 id="Dijkstra.UpdateDistances">func (*Dijkstra) <a href="/src/target/dijkstra.go?s=1577:1648#L62">UpdateDistances</a>
					<a class="permalink" href="#Dijkstra.UpdateDistances">&#xb6;</a>
				</h3>
				<pre>func (d *<a href="#Dijkstra">Dijkstra</a>) UpdateDistances(s1, s2, edge <a href="/pkg/builtin/#string">string</a>, s1s2Weight <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
UpdateDistances updates the costs of s2 if it is not minimal. It also stores the edge crossed to get that minimal cost.
</p>

				
				
				
			
		
			
			
			<h2 id="Edge">type <a href="/src/target/edge.go?s=118:311#L1">Edge</a>
				<a class="permalink" href="#Edge">&#xb6;</a>
			</h2>
			<p>
Edge represents an edge instance. It inheritates from Vertex structure.
</p>

			<pre>type Edge struct {
    <a href="#Vertex">Vertex</a>
<span id="Edge.Froms"></span>    Froms map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a> `json:&#34;-&#34;` <span class="comment">// list of vertices from which the edge is reachable</span>
<span id="Edge.Tos"></span>    Tos   map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a> `json:&#34;-&#34;` <span class="comment">// list of vertices that the edge can reach</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewEdge">func <a href="/src/target/edge.go?s=344:390#L5">NewEdge</a>
					<a class="permalink" href="#NewEdge">&#xb6;</a>
				</h3>
				<pre>func NewEdge(id, label, from, to <a href="/pkg/builtin/#string">string</a>) *<a href="#Edge">Edge</a></pre>
				<p>
NewEdge returns a new edge.
</p>

				
				
			
				
				<h3 id="NewMultiEdge">func <a href="/src/target/edge.go?s=553:622#L12">NewMultiEdge</a>
					<a class="permalink" href="#NewMultiEdge">&#xb6;</a>
				</h3>
				<pre>func NewMultiEdge(id, label <a href="/pkg/builtin/#string">string</a>, froms, tos map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a>) *<a href="#Edge">Edge</a></pre>
				<p>
NewMultiEdge returns a new multiedge.
</p>

				
				
			

			
				
				<h3 id="Edge.ToJSON">func (Edge) <a href="/src/target/edge.go?s=760:805#L17">ToJSON</a>
					<a class="permalink" href="#Edge.ToJSON">&#xb6;</a>
				</h3>
				<pre>func (e <a href="#Edge">Edge</a>) ToJSON() map[<a href="/pkg/builtin/#string">string</a>]interface{}</pre>
				<p>
ToJSON formats the vertex to JSON. Froms and Tos fields are converted to slice.
</p>

				
				
				
			
		
			
			
			<h2 id="Graph">type <a href="/src/target/graph.go?s=71:236#L1">Graph</a>
				<a class="permalink" href="#Graph">&#xb6;</a>
			</h2>
			<p>
Graph represents a graph instance.
</p>

			<pre>type Graph struct {
<span id="Graph.Vertices"></span>    Vertices    map[<a href="/pkg/builtin/#string">string</a>]*<a href="#Vertex">Vertex</a>
<span id="Graph.Edges"></span>    Edges       map[<a href="/pkg/builtin/#string">string</a>]*<a href="#Edge">Edge</a>
<span id="Graph.Connections"></span>    Connections map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#string">string</a> <span class="comment">// indexes connection between vertices and edges</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewGraph">func <a href="/src/target/graph.go?s=302:324#L5">NewGraph</a>
					<a class="permalink" href="#NewGraph">&#xb6;</a>
				</h3>
				<pre>func NewGraph() *<a href="#Graph">Graph</a></pre>
				<p>
NewGraph returns a new graph initilizated with empty fields.
</p>

				
				
			

			
				
				<h3 id="Graph.AddEdge">func (*Graph) <a href="/src/target/graph.go?s=877:909#L22">AddEdge</a>
					<a class="permalink" href="#Graph.AddEdge">&#xb6;</a>
				</h3>
				<pre>func (g *<a href="#Graph">Graph</a>) AddEdge(e *<a href="#Edge">Edge</a>)</pre>
				<p>
AddEdge adds an edge to the graph and connects it the specified vertices. It also stores the inverse connections.
Adding an edge connecting vertices that does not exist raises an error.
</p>

				
				
				
			
				
				<h3 id="Graph.AddVertex">func (*Graph) <a href="/src/target/graph.go?s=621:657#L16">AddVertex</a>
					<a class="permalink" href="#Graph.AddVertex">&#xb6;</a>
				</h3>
				<pre>func (g *<a href="#Graph">Graph</a>) AddVertex(v *<a href="#Vertex">Vertex</a>)</pre>
				<p>
AddVertex adds a vertex to the graph.
</p>

				
				
				
			
				
				<h3 id="Graph.Connect">func (*Graph) <a href="/src/target/graph.go?s=1674:1721#L48">Connect</a>
					<a class="permalink" href="#Graph.Connect">&#xb6;</a>
				</h3>
				<pre>func (g *<a href="#Graph">Graph</a>) Connect(from, to, label <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
Connect adds specified connection to the graph indexed on label.
</p>

				
				
				
			
				
				<h3 id="Graph.GetAccessibleVertices">func (Graph) <a href="/src/target/graph.go?s=3892:3982#L119">GetAccessibleVertices</a>
					<a class="permalink" href="#Graph.GetAccessibleVertices">&#xb6;</a>
				</h3>
				<pre>func (g <a href="#Graph">Graph</a>) GetAccessibleVertices(vertex <a href="/pkg/builtin/#string">string</a>, constraint <a href="#Constraint">Constraint</a>) map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
GetAccessibleVertices returns accessible vertices from vertex using private method getAccessibleVerticesRecursive.
</p>

				
				
				
			
				
				<h3 id="Graph.GetConnections">func (*Graph) <a href="/src/target/graph.go?s=1507:1564#L43">GetConnections</a>
					<a class="permalink" href="#Graph.GetConnections">&#xb6;</a>
				</h3>
				<pre>func (g *<a href="#Graph">Graph</a>) GetConnections(id, label <a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
GetConnections returns reachable vertices or edges from specified edge or vertex, respectively.
</p>

				
				
				
			
				
				<h3 id="Graph.GetNeighbors">func (Graph) <a href="/src/target/graph.go?s=1882:1963#L54">GetNeighbors</a>
					<a class="permalink" href="#Graph.GetNeighbors">&#xb6;</a>
				</h3>
				<pre>func (g <a href="#Graph">Graph</a>) GetNeighbors(vertex <a href="/pkg/builtin/#string">string</a>, constraint <a href="#Constraint">Constraint</a>) map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
GetNeighbors retrieves neighbors of vertex under specified constraints.
</p>

				
				
				
			
				
				<h3 id="Graph.GetNeighborsWithCostsAndEdges">func (Graph) <a href="/src/target/graph.go?s=2693:2828#L80">GetNeighborsWithCostsAndEdges</a>
					<a class="permalink" href="#Graph.GetNeighborsWithCostsAndEdges">&#xb6;</a>
				</h3>
				<pre>func (g <a href="#Graph">Graph</a>) GetNeighborsWithCostsAndEdges(vertex <a href="/pkg/builtin/#string">string</a>, constraint <a href="#Constraint">Constraint</a>, costs ...<a href="/pkg/builtin/#string">string</a>) (map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>, map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
GetNeighborsWithCostsAndEdges returns reachable vertices. For each neighbor, it returns with the minimal cost and the crossed edge (in the case of multiedges).
</p>

				
				
				
			
		
			
			
			<h2 id="Path">type <a href="/src/target/path.go?s=94:196#L1">Path</a>
				<a class="permalink" href="#Path">&#xb6;</a>
			</h2>
			<p>
Path instance helps building a path from Dijkstra result.
</p>

			<pre>type Path struct {
<span id="Path.From"></span>    From   <a href="/pkg/builtin/#string">string</a>
<span id="Path.To"></span>    To     <a href="/pkg/builtin/#string">string</a>
<span id="Path.PredsV"></span>    PredsV map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>
<span id="Path.PredsE"></span>    PredsE map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewPath">func <a href="/src/target/path.go?s=234:304#L6">NewPath</a>
					<a class="permalink" href="#NewPath">&#xb6;</a>
				</h3>
				<pre>func NewPath(from, to <a href="/pkg/builtin/#string">string</a>, vertices, edges map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>) *<a href="#Path">Path</a></pre>
				<p>
NewPath returns a path instance.
</p>

				
				
			

			
				
				<h3 id="Path.Append">func (Path) <a href="/src/target/path.go?s=841:886#L35">Append</a>
					<a class="permalink" href="#Path.Append">&#xb6;</a>
				</h3>
				<pre>func (p <a href="#Path">Path</a>) Append(path2 []<a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
Append returns the path concatenated with the specified path.
</p>

				
				
				
			
				
				<h3 id="Path.Get">func (Path) <a href="/src/target/path.go?s=398:426#L11">Get</a>
					<a class="permalink" href="#Path.Get">&#xb6;</a>
				</h3>
				<pre>func (p <a href="#Path">Path</a>) Get() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>
Get returns the path as a slice of strings.
</p>

				
				
				
			
		
			
			
			<h2 id="Vertex">type <a href="/src/target/vertex.go?s=83:270#L1">Vertex</a>
				<a class="permalink" href="#Vertex">&#xb6;</a>
			</h2>
			<p>
Vertex represents a vertex instance.
</p>

			<pre>type Vertex struct {
<span id="Vertex.ID"></span>    ID    <a href="/pkg/builtin/#string">string</a>              `json:&#34;id&#34;`
<span id="Vertex.Label"></span>    Label <a href="/pkg/builtin/#string">string</a>              `json:&#34;label&#34;`
<span id="Vertex.Props"></span>    Props map[<a href="/pkg/builtin/#string">string</a>][]<a href="/pkg/builtin/#string">string</a> `json:&#34;props&#34;`
<span id="Vertex.Costs"></span>    Costs map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>      `json:&#34;costs&#34;`
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewVertex">func <a href="/src/target/vertex.go?s=307:347#L6">NewVertex</a>
					<a class="permalink" href="#NewVertex">&#xb6;</a>
				</h3>
				<pre>func NewVertex(id, label <a href="/pkg/builtin/#string">string</a>) *<a href="#Vertex">Vertex</a></pre>
				<p>
NewVertex returns a new vertex.
</p>

				
				
			

			
				
				<h3 id="Vertex.AddProp">func (*Vertex) <a href="/src/target/vertex.go?s=463:507#L11">AddProp</a>
					<a class="permalink" href="#Vertex.AddProp">&#xb6;</a>
				</h3>
				<pre>func (v *<a href="#Vertex">Vertex</a>) AddProp(prop, value <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
AddProp adds a property to the vertex.
</p>

				
				
				
			
				
				<h3 id="Vertex.Satisfies">func (Vertex) <a href="/src/target/vertex.go?s=789:842#L21">Satisfies</a>
					<a class="permalink" href="#Vertex.Satisfies">&#xb6;</a>
				</h3>
				<pre>func (v <a href="#Vertex">Vertex</a>) Satisfies(constraint <a href="#Constraint">Constraint</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Satisfies returns whether or not the vertex satisfies the props and costs (threshold) of the constraint.
</p>

				
				
				
			
				
				<h3 id="Vertex.SetCost">func (*Vertex) <a href="/src/target/vertex.go?s=604:652#L16">SetCost</a>
					<a class="permalink" href="#Vertex.SetCost">&#xb6;</a>
				</h3>
				<pre>func (v *<a href="#Vertex">Vertex</a>) SetCost(cost <a href="/pkg/builtin/#string">string</a>, value <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
SetCost sets a cost value for the vertex.
</p>

				
				
				
			
				
				<h3 id="Vertex.ToJSON">func (Vertex) <a href="/src/target/vertex.go?s=1433:1480#L51">ToJSON</a>
					<a class="permalink" href="#Vertex.ToJSON">&#xb6;</a>
				</h3>
				<pre>func (v <a href="#Vertex">Vertex</a>) ToJSON() map[<a href="/pkg/builtin/#string">string</a>]interface{}</pre>
				<p>
ToJSON formats the vertex to JSON.
</p>

				
				
				
			
		
	

	





